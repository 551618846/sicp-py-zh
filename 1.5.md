# 1.5 控制

> 来源：[1.5   Control](http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/functions.html#control)

> 译者：[飞龙](https://github.com/wizardforcel)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

我们现在可以定义的函数能力有限，因为我们还不知道一种方法来进行测试，并且根据测试结果来执行不同的操作。控制语句可以让我们完成这件事。它们不像严格的求值子表达式那样从左向右编写，并且可以从它们控制解释器下一步做什么当中得到它们的名称。这可能基于表达式的值。

## 1.5.1 语句

目前为止，我们已经初步思考了如何求出表达式。然而，我们已经看到了三种语句：赋值、`def`和`return`语句。这些 Python 代码并不是表达式，虽然它们中的一部分是表达式。

要强调的是，语句的值是不相干的（或不存在的），我们使用执行而不是求值来描述语句。每个语句都描述了对解释器状态的一些改变，执行语句会应用这些改变。像我们之前看到的`return`和赋值语句那样，语句的执行涉及到求解所包含的子表达式。

表达式也可以作为语句执行，其中它们会被求值，但是它们的值会舍弃。执行纯函数没有什么副作用，但是执行非纯函数会产生效果作为函数调用的结果。

考虑下面这个例子：

```py
>>> def square(x):
        mul(x, x) # Watch out! This call doesn't return a value.
```

这是有效的 Python 代码，但是并不是想表达的意思。函数体由表达式组成。表达式本身是个有效的语句，但是语句的效果是，`mul`函数被调用了，然后结果被舍弃了。如果你希望对表达式的结果做一些事情，你需要这样做：使用赋值语句来储存它，或者使用`return`语句将它返回：

```py
>>> def square(x):
        return mul(x, x)
```

有时编写一个函数体是表达式的函数是有意义的，例如调用类似`print`的非纯函数：

```py
>>> def print_square(x):
        print(square(x))
```

在最高层级上，Python 解释器的工作就是执行由语句组成的程序。但是，许多有意思的计算工作来源于求解表达式。语句管理程序中不同表达式之间的关系，以及它们的结果会怎么样。

## 1.5.2 复合语句

通常，Python 的代码是语句的序列。一条简单的语句是一行不以分号结束的代码。复合语句之所以这么命名，因为它是其它（简单或复合）语句的复合。复合语句一般占据多行，并且以一行以冒号结尾的头部开始，它标识了语句的类型。同时，一个头部和一组缩进的代码叫做子句（或从句）。复合语句由一个或多个子句组成。

```
<header>:
    <statement>
    <statement>
    ...
<separating header>:
    <statement>
    <statement>
    ...
...
```

我们可以这样理解我们已经见到的语句：

+ 表达式、返回语句和赋值语句都是简单语句。
+ `def`语句是复合语句。`def`头部之后的组定义了函数体。

为每种头部特化的求值规则指导了组内的语句什么时候以及是否会被执行。我们说头部控制语句组。例如，在`def`语句的例子中，我们看到返回表达式并不会立即求值，而是储存起来用于以后的使用，当所定义的函数最终调用时就会求值。

我们现在也能理解多行的程序了。

+ 执行语句序列需要执行第一条语句。如果这个语句不是重定向控制，之后执行语句序列的剩余部分，如果存在的话。

这个定义揭示出递归定义“序列”的基本结构：一个序列可以划分为它的第一个元素和其余元素。语句序列的“剩余”部分也是一个语句序列。所以我们可以递归应用这个执行规则。这个序列作为递归数据结构的看法会在随后的章节中再次出现。

这一规则的重要结果就是语句顺序执行，但是随后的语句可能永远不会执行到，因为有重定向控制。

**实践指南：**在缩进代码组时，所有行必须以相同数量以及相同方式缩进（空格而不是Tab）。任何缩进的变动都会导致错误。

## 1.5.3 定义函数 II：局部赋值


