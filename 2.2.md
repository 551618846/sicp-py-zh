# 2.2 数据抽象

> 来源：[2.2   Data Abstraction](http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/objects.html#introduction)

> 译者：[飞龙](https://github.com/wizardforcel)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

由于我们希望在程序中表达世界中的大量事物，我们发现它们的大多数都具有复合结构。日期是年月日，地理位置是精度和纬度。为了表示位置，我们希望程序语言具有将精度和纬度“粘合”为一对数据的能力 -- 也就是一个复合数据结构 -- 使我们的程序能够以一种方式操作数据，将位置看做单个概念单元，它拥有两个部分。

复合数据的使用也让我们增加程序的模块性。如果我们可以直接将地理位置看做对象来操作，我们就可以将程序的各个部分分离，它们根据这些值如何表示来从本质上处理这些值。将某个部分从程序中分离的一般技巧是一种叫做数据抽象的强大的设计方法论。这个部分用于处理数据表示，而程序用于操作数据。数据抽象使程序更易于设计、维护和修改。

数据抽象类似于函数抽象的特征。当我们创建函数抽象时，函数如何实现的细节被隐藏了，而且特定的函数本身可以被任何具有相同行为的函数替换。换句话说，我们可以构造抽象来使函数的使用方式和函数的实现细节分离。与之相似，数据抽象是一种方法论，使我们将复合数据对象的使用细节与它的构造方式隔离。

数据抽象的基本概念是构造操作抽象数据的程序。也就是说，我们的程序应该以一种方式来使用数据，对数据做出尽可能少的假设。同时，需要定义具体的数据表示，独立于使用数据的程序。我们系统中这两部分的接口是一系列函数，叫做选择器和构造器，它们基于具体表示实现了抽象数据。为了演示这个技巧，我们需要考虑如何设计一系列函数来操作有理数。

当你阅读下一节时，要记住当今编写的多数 Python 代码使用了非常高级的抽象数据类型，它们内建于语言中，比如类、字典和列表。由于我们正在了解这些抽象的工作原理，我们自己不能使用它们。所以，我们会编写一些不那么 Python 化的代码 -- 它并不是在语言中实现我们的概念的通常方式。但是，我们所编写的代码处于教育目的，它展示了这些抽象如何构建。要记住计算机科学并不只是学习如何使用变参语言，也学习它们的工作原理。

## 2.2.1 示例：有理数的算术

有理数可表示为整数的比值，并且它组成了实数的一个重要子类。类似于`1/3`或者`17/29`的有理数通常可编写为：

```
<numerator>/<denominator>
```

其中，`<numerator>`和`<denominator>`都是值为整数的占位符。两部分都需要值为有理数的特征。

有理数在计算机科学中很重要，因为它们就像整数那样，可以准确表示。无理数（比如`pi` 或者 `e` 或者 `sqrt(2)`）会使用有限的二元展开代替为近似值。所以，有理数的处理原则上应该让我们避免算术中的近似误差。

但是，一旦我们真正将分子与分母相除，我们就会只剩下截断的小数近似值：

```py
>>> 1/3
0.3333333333333333
```

当我们开始执行测试时，这个近似值的问题就会出现：

```py
>>> 1/3 == 0.333333333333333300000  # Beware of approximations
True
```

计算机如何将实数近似为定长的小数扩展，是另一门课的话题。这里的重要概念时，通过将有理数表示为整数的比值，我们能够完全避免近似问题。所以，我们出于精确，希望将分子和分母分离，但是将它们看做一个单元。

我们从函数抽象中了解到，我们可以在了解某些部分的实现之前开始编出东西来。让我们通过假设我们已经拥有一种从分子和分母中构造有理数的方式来开始。我们也假设，给定一个有理数，我们都有办法来提取（或选中）它的分子和分母。让我们进一步假设，构造器和选择器以下面三个函数来提供：

+ `make_rat(n, d)`返回分子为`n`和分母为`d`的有理数。
+ `numer(x)`返回有理数`x`的分子。
+ `denom(x)`返回有理数`x`的分母。

我们在这里正在使用一个强大的合成策略：心想事成。我们并没有说有理数如何表示，或者`numer`、`denom`和`make_rat`如何实现。即使这样，如果我们拥有了这三个函数，我们就可以执行加法、乘法，以及测试有理数的相等性，通过调用它们：

```py
>>> def add_rat(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return make_rat(nx * dy + ny * dx, dx * dy)
>>> def mul_rat(x, y):
        return make_rat(numer(x) * numer(y), denom(x) * denom(y))
>>> def eq_rat(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
```

现在我们拥有了基于选择器函数`numer`和`denom`，以及构造器函数`make_rat`定义的有理数操作。但是我们还没有定义这些函数。我们需要以某种方式来将分子和分母粘合为一个单元。

## 2.2.2

为了实现我们的数据抽象的具体层面，Python 提供了一种复合数据结构叫做`typle`，它可以由逗号分隔的值来构造。虽然并不是严格要求，圆括号通常在元组周围。

```py
>>> (1, 2)
(1, 2)
```

元组的元素可以由两种方式解构。第一种是我们熟悉的多重赋值：

```py
>>> pair = (1, 2)
>>> pair
(1, 2)
>>> x, y = pair
>>> x
1
>>> y
2
```

实际上，多重赋值的本质是创建和解构元组。

访问元素元素的第二种方式是通过下标运算符，写作方括号：

```py
>>> pair[0]
1
>>> pair[1]
2
```

Python 中的元组（以及多数其它编程语言中的序列）下表都以 0 开始，也就是说，下标 0 表示第一个元素，下标 1 表示第二个元素，以此类推。我们对这个下标惯例的直觉是，下标表示一个元素距离元组开头有多远。

与元素选择操作等价的函数叫做`getitem`，它也使用下标以 0 开始的位置来在元组中选择元素。

元素是原始类型，也就是说 Python 的内建运算符可以操作它们。我们不久之后再来看元素的完整特性。现在，我们只对元组如何作为胶水来实现抽象数据类型感兴趣。

**表示有理数。**元素提供了一个自然的方式来将有理数实现为一对整数：分子和分母。我们可以通过操作二元组来实现我们的有理数构造器和选择器函数。

```py
>>> def make_rat(n, d):
        return (n, d)
>>> def numer(x):
        return getitem(x, 0)
>>> def denom(x):
        return getitem(x, 1)
```

用于打印有理数的函数完成了我们对抽象数据结构的实现。

```py
>>> def str_rat(x):
        """Return a string 'n/d' for numerator n and denominator d."""
        return '{0}/{1}'.format(numer(x), denom(x))
```

将它与我们之前定义的算术运算放在一起，我们可以使用我们定义的函数来操作有理数了。

```py
>>> half = make_rat(1, 2)
>>> str_rat(half)
'1/2'
>>> third = make_rat(1, 3)
>>> str_rat(mul_rat(half, third))
'1/6'
>>> str_rat(add_rat(third, third))
'6/9'
```

就像最后的例子所展示的那样，我们的有理数实现并没有将有理数化为最简。我们可以通过修改`make_rat`来补救。如果我们拥有用于计算两个整数的最大公约数的函数，我们可以在构造有理数对之前将分子和分母化为最简。这可以使用许多实用工具，例如 Python 库中的现存函数。

```py
>>> from fractions import gcd
>>> def make_rat(n, d):
        g = gcd(n, d)
        return (n//g, d//g)
```

双斜杠运算符`//`表示整数除法，它会向下取整除法结果的小数部分。由于我们知道`g`能整除`n`和`d`，整数除法正好适用于这里。现在我们的

```py
>>> str_rat(add_rat(third, third))
'2/3'
```

符合要求。这个修改值刚启动了构造器，并没有改动任何实现实际算术操作的函数。

**扩展阅读。**上面的`str_rat`实现使用了格式化字符串，它包含了值的占位符。如何使用格式化字符串和`format`方法的细节请见 Dive Into Python 3 的[格式化字符串](http://diveintopython3.ep.io/strings.html#formatting-strings)一节。
