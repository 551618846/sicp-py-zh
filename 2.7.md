# 2.7 泛用方法

> 来源：[2.7   Generic Operations](http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/objects.html#generic-operations)

> 译者：[飞龙](https://github.com/wizardforcel)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

这一章中我们引入了复合数据类型，以及由构造器和选择器实现的数据抽象技巧。使用消息传递，我们就能使抽象数据类型直接拥有行为。使用对象隐喻，我们可以将数据的表示和用于操作数据的方法绑定在一起，从而使数据驱动的程序模块化，并带有局部状态。

但是，我们仍然必须展示，我们的对象系统允许我们在大型程序中灵活组合不同类型的对象。点运算符的消息传递仅仅是一种用于使用多个对象构建组合表达式的方式。这一节中，我们会探索一些用于组合和操作不同类型对象的方式。

## 2.7.1 字符串转换

我们在这一章最开始说，对象值的行为应该类似它所表达的数据，包括产生它自己的字符串表示。数据值的字符串表示在类似 Python 的交互式语言中尤其重要，其中“读取-求值-打印”的循环需要每个值都拥有某种字符串表示形式。

字符串值为人们的信息交流提供了基础的媒介。字符序列可以在屏幕上渲染，打印到纸上，大声朗读，转换为盲文，或者以莫尔兹码广播。字符串对编程而言也非常基础，因为它们可以表示 Python 表达式。对于一个对象，我们可能希望生成一个字符串，当作为 Python 表达式解释时，求值为等价的对象。

Python 规定，所有对象都应该能够产生两种不同的字符串表示：一种是人类可解释的文本，另一种是 Python 可解释的表达式。字符串的构造函数`str`返回人类可读的字符串。在可能的情况下，`repr`函数返回一个 Python 表达式，它可以求值为等价的对象。`repr`的文档字符串解释了这个特性：

```
repr(object) -> string

Return the canonical string representation of the object.
For most object types, eval(repr(object)) == object.
```

在表达式的值上调用`repr`的结果就是 Python 在交互式会话中打印的东西。

```py
>>> 12e12
12000000000000.0
>>> print(repr(12e12))
12000000000000.0
```

在不存在任何可以求值为原始值的表达式的情况中，Python 会产生一个代理：

```py
>>> repr(min)
'<built-in function min>'
```

`str`构造器通常与`repr`相同，但是有时会提供更加可解释的文本表示。例如，我们可以看到`str`和`repr`对于日期的不同：

```py
>>> from datetime import date
>>> today = date(2011, 9, 12)
>>> repr(today)
'datetime.date(2011, 9, 12)'
>>> str(today)
'2011-09-12'
```

`repr`函数的定义出现了新的挑战：我们希望它对所有数据类型都正确应用，甚至是那些在`repr`实现时还不存在的类型。我们希望它像一个多态函数，可以作用于许多（多）不同形式（态）的数据。

消息传递提供了这个问题的解决方案：`repr`函数在参数上调用叫做`__repr__`的函数。

```py
>>> today.__repr__()
'datetime.date(2011, 9, 12)'
```

通过在用户定义的类上实现同一方法，我们就可以将`repr`的适用性扩展到任何我们以后创建的类。这个例子强调了消息传递的另一个普遍的好处：就是它提供了一种机制，用于将现有函数的职责范围扩展到新的对象。

`str`构造器以类似的方式实现：它在参数上调用了叫做`__str__`的方法。

```py
>>> today.__str__()
'2011-09-12'
```

这些多态函数是一个更普遍原则的例子：特定函数应该作用域多种数据类型。这里举例的消息传递方法仅仅只多态函数实现家族的一员。剩下的部分会探索一些选择。

