# 3.5 组合语言的解释器

> 来源：[3.5   Interpreters for Languages with Combination](http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/interpretation.html#interpreters-for-languages-with-combination)

> 译者：[飞龙](https://github.com/wizardforcel)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

运行在任何现代计算机上的软件都以多种编程语言写成。其中有物理语言，例如用于特定计算机的机器语言。这些语言涉及到基于独立储存位和原始机器指令的数据表示和控制。机器语言的程序员涉及到使用提供的硬件，为资源有限的计算构建系统和功能的高效实现。高阶语言构建在机器语言智商，隐藏了数据表示为位集，以及程序表示为原始指令序列的细节。这些语言拥有组合和抽象的手段，例如过程定义，它们适用于组织大规模的软件系统。

元语言抽象 -- 建立了新的语言 -- 并在所有工程设计分支中起到重要作用。它对于计算机编程尤其重要，因为我们不仅仅可以在编程中构想出新的语言，我们也能够通过构建解释器来实现它们。编程语言的解释器是一个函数，它在语言的表达式上调用，执行求解表达式所需的操作。

我们现在已经开始了技术之旅，通过这种技术，编程语言可以建立在其它语言之上。我们首先会为计算器定义解释器，它是一种受限的语言，和 Python 调用表达式具有相同的语法。我们之后会从零开始开发 Scheme 和 Logo 语言的解释器，它们都是 Lisp 的方言，Lisp 是现在仍旧广泛使用的第二老的语言。我们所创建的解释器，在某种意义上，会允许我们使用 Logo 编写完全通用的程序。为了这样做，它会实现我们已经在这门课中开发的求值的环境模型。

## 3.5.1 计算器

我们的第一种新语言叫做计算器，一种用于加减乘除的算术运算的表达式语言。计算器拥有 Python 调用表达式的语法，但是他的运算符对于所接受的参数数量等价灵活。例如，计算器运算符`mul`和`add`可接受任何数量的参数：

```py
calc> add(1, 2, 3, 4)
10
calc> mul()
1
```

`sub`运算符拥有两种行为：传入一个运算符，它会对运算符取反。传入至少两个，它会从第一个参数中减掉剩余的参数。`div`运算符拥有 Python 的`operator.truediv`的语义，只接受两个参数。

```py
calc> sub(10, 1, 2, 3)
4
calc> sub(3)
-3
calc> div(15, 12)
1.25
```

就像 Python 中那样，调用表达式的嵌套提供了计算器语言中的组合手段。为了精简符号，我们使用运算符的标准符号来代替名称：

```py
calc> sub(100, mul(7, add(8, div(-12, -3))))
16.0
calc> -(100, *(7, +(8, /(-12, -3))))
16.0
```

我们会使用 Python 实现计算器解释器。也就是说，我们会编写 Python 程序来接受字符串作为输入，并返回求值结果。如果输入时复合要求的计算器表达式，结果为字符串，反之会产生合适的异常。计算器语言解释器的核心是叫做`calc_eval`的递归函数，它会求解树形表达式对象。

**表达式树。**到目前为止，我们在描述求值过程中所引用的表达式树，还是概念上的实体。我们从没有显式将表达式树表示为程序中的数据。为了编程解释器，我们必须将表达式当做数据操作。在这一章中，组多我们之前介绍过的概念都会最终以代码实现。

计算器中的基本表达式只是一个数值，类型为`int`或`float`。所有复合表达式都是调用表达式。调用表达式表示为拥有两个属性实例的`Exp`类。计算器的`operator`总是字符串：算数运算符的名称或符号。`operands`要么是基本表达式，要么是`Exp`的实例本身。

```py
>>> class Exp(object):
        """A call expression in Calculator."""
        def __init__(self, operator, operands):
            self.operator = operator
            self.operands = operands
        def __repr__(self):
            return 'Exp({0}, {1})'.format(repr(self.operator), repr(self.operands))
        def __str__(self):
            operand_strs = ', '.join(map(str, self.operands))
            return '{0}({1})'.format(self.operator, operand_strs)
```

`Exp`实例定义了两个字符串方法。`__repr__`方法返回 Python 表达式，而`__str__`方法返回计算器表达式。

```py
>>> Exp('add', [1, 2])
Exp('add', [1, 2])
>>> str(Exp('add', [1, 2]))
'add(1, 2)'
>>> Exp('add', [1, Exp('mul', [2, 3, 4])])
Exp('add', [1, Exp('mul', [2, 3, 4])])
>>> str(Exp('add', [1, Exp('mul', [2, 3, 4])]))
'add(1, mul(2, 3, 4))'
```

最后的例子演示了`Exp`类如何通过包含`Exp`的实例作为`operands`元素，来表示表达式树中的层次结构。

**求值。**`calc_eval`函数接受表达式作为参数，并返回它的值。它根据表达式的形式为表达式分类，并且指导它的求值。对于计算器，表达式的两种句法形式是数值或调用表达式，后者是`Exp`的实例。使之是自求值的，它们可以直接从`calc_eval`中返回。调用表达式需要使用函数。

调用表达式首先通过将`calc_eval`函数递归映射到操作数的列表，计算出参数列表来求值。之后，在第二个函数`calc_apply`中，运算符会作用于这些参数上。

计算器语言足够简单，我们可以轻易地在单一函数中表达每个运算符应用的逻辑。在`calc_apply`中，每种条件子句对应一个运算符。

```py
>>> from operator import mul
>>> from functools import reduce
>>> def calc_apply(operator, args):
        """Apply the named operator to a list of args."""
        if operator in ('add', '+'):
            return sum(args)
        if operator in ('sub', '-'):
            if len(args) == 0:
                raise TypeError(operator + ' requires at least 1 argument')
            if len(args) == 1:
                return -args[0]
            return sum(args[:1] + [-arg for arg in args[1:]])
        if operator in ('mul', '*'):
            return reduce(mul, args, 1)
        if operator in ('div', '/'):
            if len(args) != 2:
                raise TypeError(operator + ' requires exactly 2 arguments')
            numer, denom = args
            return numer/denom
```

上面，每个语句组计算了不同运算符的结果，或者当参数错误时产生合适的`TypeError`。`calc_apply`函数可以直接调用，但是必须转入值的列表作为参数，而不是运算符表达式的列表。

```py
>>> calc_apply('+', [1, 2, 3])
6
>>> calc_apply('-', [10, 1, 2, 3])
4
>>> calc_apply('*', [])
1
>>> calc_apply('/', [40, 5])
8.0
```

`calc_eval`的作用是，执行合适的`calc_apply`调用，通过首先计算操作数子表达式的值，之后将它们作为参数传入`calc_apply`。于是，`calc_eval`可以接受嵌套表达式。

```py
>>> e = Exp('add', [2, Exp('mul', [4, 6])])
>>> str(e)
'add(2, mul(4, 6))'
>>> calc_eval(e)
26
```

`calc_eval`的结构是个类型（表达式的形式）分发的例子。第一种表达式是数值，不需要任何的额外求值步骤。通常，基本表达式不需要任何额外的求值步骤，叫做自求值。计算器语言中唯一的自求值表达式就是数值，但是在通用语言中可能也包括字符串、布尔值，以及其它。

**“读取-求值-打印”循环。**和解释器交互的典型方式是通过“读取-求值-打印”循环（REPL），它是一种交互模式，读取表达式、对其求值，之后为用户打印出结果。Python 交互式会话就是这种循环的例子。

REPL 的实现与所使用的解释器无关。下面的`read_eval_print_loop`函数使用内建的`input`函数，从用户接受一行文本作为输入。它使用语言特定的`calc_parse`函数构建表达式树。`calc_parse`定义在随后的解析一节中。最后，它打印出对由`calc_parse`返回的表达式树调用`calc_eval`的结果。

```py
>>> def read_eval_print_loop():
        """Run a read-eval-print loop for calculator."""
        while True:
            expression_tree = calc_parse(input('calc> '))
            print(calc_eval(expression_tree))
```

`read_eval_print_loop`的这个版本包含所有交互式界面的必要组件。一个样例会话可能像这样：

```py
calc> mul(1, 2, 3)
6
calc> add()
0
calc> add(2, div(4, 8))
2.5
```

这个循环没有实现终端或者错误处理机制。我们可以通过向用户报告错误来改进这个界面。我们也可以允许用户通过发射键盘中断信号（`Control-C`），或文件末尾信号（`Control-D`）来退出循环。为了实现这些改进，我们将原始的`while`语句组放在`try`语句中。第一个`except`子句处理了由`calc_parse`产生的`SyntaxError`异常，也处理了由`calc_eval`产生的`TypeError`和`ZeroDivisionError`异常。

```py
>>> def read_eval_print_loop():
        """Run a read-eval-print loop for calculator."""
        while True:
            try:
                expression_tree = calc_parse(input('calc> '))
                print(calc_eval(expression_tree))
            except (SyntaxError, TypeError, ZeroDivisionError) as err:
                print(type(err).__name__ + ':', err)
            except (KeyboardInterrupt, EOFError):  # <Control>-D, etc.
                print('Calculation completed.')
                return
```

这个循环实现报告错误而不退出循环。发生错误时不退出程序，而是在错误消息之后重新开始循环可以让用户回顾他们的表达式。通过导入`readline`模块，用户甚至可以使用上箭头或`Control-P`来回忆他们之前的输入。最终的结果剔红了错误信息报告的界面：

```py
calc> add
SyntaxError: expected ( after add
calc> div(5)
TypeError: div requires exactly 2 arguments
calc> div(1, 0)
ZeroDivisionError: division by zero
calc> ^DCalculation completed.
```

在我们将解释器推广到除了计算器之外的语言时，我们会看到，`read_eval_print_loop`由解析函数、求值函数，和由`try`语句处理的异常类型参数化。除了这些修改之外，任何 REPL 都可以使用相同的结构来实现。

