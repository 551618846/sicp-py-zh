# 3.6 抽象语言的解释器

> 来源：[3.6   Interpreters for Languages with Abstraction](http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/interpretation.html#interpreters-for-languages-with-abstraction)

> 译者：[飞龙](https://github.com/wizardforcel)

> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

计算器语言提供了一种手段，来组合一些嵌套的调用表达式。然而，我们却没有办法定义新的运算符，将值赋给名称，或者表达通用的计算方法。总之，计算器并不以任何方式支持抽象。所以，它并不是特别强大或通用的编程语言。我们现在转到定义一种通用编程语言的任务中，这门语言通过将名称绑定到值以及定义新的操作来支持抽象。

我们并不是进一步扩展简单的计算器语言，而是重新开始，并且为 Logo 语言开发解释器。Logo 并不是为这门课发明的语言，而是一种经典的命令式语言，拥有许多解释器实现和自己的开发者社区。

上一章，我们将完整的解释器表示为 Python 源码，这一章使用描述性的方式。某个配套工程需要你通过构建完整的 Logo 函数式解释器来实现这里展示的概念。

## 3.6.1 Scheme 语言

Scheme 是 Lisp 的一种方言，Lisp 是现在仍在广泛使用的第二老（在 Fortran 之后）的编程语言。Scheme首次在 1975 年由 Gerald Sussman 和 Guy Steele 描述。Revised(4) Report on the Algorithmic Language Scheme 的引言中写道：

> 编程语言不应该通过堆砌特性，而是应该通过移除那些使额外特性变得必要的缺点和限制来设计。Scheme 表明，用于组成表达式的非常少量的规则，在没有组合方式的限制的情况下，足以组成实用并且高效的编程语言，它足够灵活，在使用中可以支持多数当今的主流编程范式。

我们将这个报告推荐给你作为 Scheme 语言的详细参考。我们这里只会设计重点。下面的描述中，我们会用到报告中的例子。

虽然它非常简单，Scheme 是一种真正的编程语言，在许多地方都类似于 Python，但是“语法糖[1]”会尽量少。基本上，所有运算符都是函数调用的形式。这里我们会描述完整的 Scheme 语言的在报告中描述的可展示的子集。

> [1] 非常遗憾，这对于 Scheme 语言的最新版本并不成立，就像 Revised(6) Report 中的那样。所以这里我们仅仅针对之前的版本。

Scheme 有多重可用的实现，它们添加了额外的过程。在 UCB，我们使用[Stk 解释器的一个修改版](http://inst.eecs.berkeley.edu/~scheme/)，它也在我们的教学服务器上以`stk`提供。不幸的是，它并不严格遵守正式规范，但它可用于我们的目的。

**使用解释器。**就像 Python 解释器[2]那样，向 Stk 键入的表达式会由“读取-求值-打印”循环求值并打印：

```scheme
>>> 3
3
>>> (- (/ (* (+ 3 7 10) (- 1000 8)) 992) 17)
3
>>> (define (fib n) (if (< n 2) n (+ (fib (- n 2)) (fib (- n 1)))))
fib
>>> '(1 (7 19))
(1 (7 19))
```

> [2] 在我们的例子中，我们使用了和 Python 相同的符号`>>>`和`...`，来表示解释器的输入行，和表示输出的非前缀行。实际上，Scheme 解释器使用不同的提示符。例子，Stk 以`STk>`来提示，并且不提示连续行。然而 Python 的惯例使输入和输出更加清晰。

**Scheme 中的值。**Scheme 中的值通常与 Python 对应。

布尔值

真值和假值，使用`#t`和`#f`来表示。Scheme 中唯一的假值（按照 Python 的含义）就是`#f`。

数值

这包括任意精度的整数、有理数、复数，和“不精确”（通常是浮点）数值。整数可用标准的十进制表示，或者通过在数字之前添加`#o`（八进制）、`#x`（十六进制）或`#b`（二进制），以其他进制表示。

符号

符号是一种字符串，但是不被引号包围。有效的字符包括字母、数字和：

```
!  $  %  &  *  /  :  <  = >  ?  ^  _  ~  +  -  .  @
```

在使用`read`函数输入时，它会读取 Scheme 表达式（也是解释器用于输入程序文本的东西），不区分符号中的大小写（在STk 实现中会转为小写）。两个带有相同表示的符号表示同一对象（并不是两个碰巧拥有相同内容的对象）。

偶对和列表

偶对是含有两个（任意类型）成员的对象，叫做它的`car`和`cdr`。`car`为`A`且`cdr`为`B`的偶对可表示为`(A . B)`。偶对（就像 Python 中的元组）可以表示列表、树和任意的层次结构。

标准的 Scheme 列表包含空的列表值（记为`()`），或者包含一个偶对，它的`car`是列表第一个元素，`cdr`是列表的剩余部分。所以，包含整数`1, 2, 3`的列表可表示为：

```scheme
(1 . (2 . (3 . ())))
```

列表无处不在，Scheme 允许我们将`(a . ())`缩略为`(a)`，将`(a . (b ...))`缩略为`(a b ...)`。所以，上面的列表通常写为：

```scheme
(1 2 3)
```

过程（函数）

就像 Python 中一样，过程（或函数）值表示一些计算，它们可以通过向函数提供参数来调用。过程要么是原始的，由 Scheme 的运行时系统提供，要么从 Scheme 表达式和环境构造（就像 Python 中那样）。没有用于函数值的直接表示，但是有一些绑定到基本函数的预定义标识符，也有一些 Scheme 表达式，在求值时会产生新的过程值。

其它类型

Scheme 也支持字符和字符串（类似 Python 的字符串，除了 Scheme 区分字符和字符串），以及向量（就像 Python 的列表）。

**程序表示。**就像其它 Lisp 版本，Scheme 的数据值也用于表示程序。例如，下面的 Scheme 列表：

```scheme
(+ x (* 10 y))
```

取决于如何使用，可表示为三个元素的列表（它的最后一个元素也是三个元素的列表），或者表达为用于计算`x+10y`的 Scheme 表达式。为了将 Scheme 值求值为程序，我们需要考虑值的类型，并按以下步骤求值：

+ 整数、布尔值、字符、字符串和向量都求值为它们自己。所以，表达式`5`求值为 5。
+ 纯符号看做变量。它们的值由当前被求值环境来决定，就像 Python 那样。
+ 非空列表以两种方式解释，取决于它们的第一个成员：
  + 如果第一个成员是特殊形式的符号（在下面描述），求值由这个特殊形式的规则执行。
  + 所有其他情况（叫做组合）中，列表的成员会以非特定的顺序（递归）求值。第一个成员必须是函数值。这个值会被调用，以列表中剩余成员的值作为参数。
+ 其他 Scheme 值（特别是，不是列表的偶对）在程序中是错误的。

例如：

```scheme
>>> 5              ; A literal.
5
>>> (define x 3)   ; A special form that creates a binding for symbol
x                   ; x.
>>> (+ 3 (* 10 x)) ; A combination.  Symbol + is bound to the primitive
33                  ; add function and * to primitive multiply.
```



